/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_RCC.h"

static const char* CMockString_AHBPrescaler = "AHBPrescaler";
static const char* CMockString_APB1Prescaler = "APB1Prescaler";
static const char* CMockString_APB2Prescaler = "APB2Prescaler";
static const char* CMockString_Clock = "Clock";
static const char* CMockString_ClockRegisterAddress = "ClockRegisterAddress";
static const char* CMockString_PLLCfg = "PLLCfg";
static const char* CMockString_Periphral = "Periphral";
static const char* CMockString_PeriphralBus = "PeriphralBus";
static const char* CMockString_RCC_CheckReadyClk = "RCC_CheckReadyClk";
static const char* CMockString_RCC_ConfigurePLL = "RCC_ConfigurePLL";
static const char* CMockString_RCC_DisableClock = "RCC_DisableClock";
static const char* CMockString_RCC_DisablePeriphral = "RCC_DisablePeriphral";
static const char* CMockString_RCC_EnableClock = "RCC_EnableClock";
static const char* CMockString_RCC_EnablePeriphral = "RCC_EnablePeriphral";
static const char* CMockString_RCC_SelectAHBPerscaler = "RCC_SelectAHBPerscaler";
static const char* CMockString_RCC_SelectAPB1Perscaler = "RCC_SelectAPB1Perscaler";
static const char* CMockString_RCC_SelectAPB2Perscaler = "RCC_SelectAPB2Perscaler";
static const char* CMockString_RCC_SelectSystemClock = "RCC_SelectSystemClock";
static const char* CMockString_ReadyMask = "ReadyMask";
static const char* CMockString_Sysclk = "Sysclk";

typedef struct _CMOCK_RCC_EnableClock_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RCC_ErrorStatus_t ReturnVal;
  int CallOrder;
  u32* Expected_ClockRegisterAddress;
  u32 Expected_Clock;

} CMOCK_RCC_EnableClock_CALL_INSTANCE;

typedef struct _CMOCK_RCC_DisableClock_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RCC_ErrorStatus_t ReturnVal;
  int CallOrder;
  u32* Expected_ClockRegisterAddress;
  u32 Expected_Clock;

} CMOCK_RCC_DisableClock_CALL_INSTANCE;

typedef struct _CMOCK_RCC_SelectSystemClock_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RCC_ErrorStatus_t ReturnVal;
  int CallOrder;
  u32 Expected_Sysclk;

} CMOCK_RCC_SelectSystemClock_CALL_INSTANCE;

typedef struct _CMOCK_RCC_EnablePeriphral_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RCC_ErrorStatus_t ReturnVal;
  int CallOrder;
  u32* Expected_PeriphralBus;
  u32 Expected_Periphral;

} CMOCK_RCC_EnablePeriphral_CALL_INSTANCE;

typedef struct _CMOCK_RCC_DisablePeriphral_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RCC_ErrorStatus_t ReturnVal;
  int CallOrder;
  u32* Expected_PeriphralBus;
  u32 Expected_Periphral;

} CMOCK_RCC_DisablePeriphral_CALL_INSTANCE;

typedef struct _CMOCK_RCC_SelectAHBPerscaler_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RCC_ErrorStatus_t ReturnVal;
  int CallOrder;
  u32 Expected_AHBPrescaler;

} CMOCK_RCC_SelectAHBPerscaler_CALL_INSTANCE;

typedef struct _CMOCK_RCC_SelectAPB1Perscaler_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RCC_ErrorStatus_t ReturnVal;
  int CallOrder;
  u32 Expected_APB1Prescaler;

} CMOCK_RCC_SelectAPB1Perscaler_CALL_INSTANCE;

typedef struct _CMOCK_RCC_SelectAPB2Perscaler_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RCC_ErrorStatus_t ReturnVal;
  int CallOrder;
  u32 Expected_APB2Prescaler;

} CMOCK_RCC_SelectAPB2Perscaler_CALL_INSTANCE;

typedef struct _CMOCK_RCC_ConfigurePLL_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RCC_ErrorStatus_t ReturnVal;
  int CallOrder;
  PLLCfgOptions_t* Expected_PLLCfg;

} CMOCK_RCC_ConfigurePLL_CALL_INSTANCE;

typedef struct _CMOCK_RCC_CheckReadyClk_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RCC_ErrorStatus_t ReturnVal;
  int CallOrder;
  u32* Expected_ClockRegisterAddress;
  u32 Expected_ReadyMask;

} CMOCK_RCC_CheckReadyClk_CALL_INSTANCE;

static struct mock_RCCInstance
{
  char RCC_EnableClock_IgnoreBool;
  RCC_ErrorStatus_t RCC_EnableClock_FinalReturn;
  char RCC_EnableClock_CallbackBool;
  CMOCK_RCC_EnableClock_CALLBACK RCC_EnableClock_CallbackFunctionPointer;
  int RCC_EnableClock_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE RCC_EnableClock_CallInstance;
  char RCC_DisableClock_IgnoreBool;
  RCC_ErrorStatus_t RCC_DisableClock_FinalReturn;
  char RCC_DisableClock_CallbackBool;
  CMOCK_RCC_DisableClock_CALLBACK RCC_DisableClock_CallbackFunctionPointer;
  int RCC_DisableClock_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE RCC_DisableClock_CallInstance;
  char RCC_SelectSystemClock_IgnoreBool;
  RCC_ErrorStatus_t RCC_SelectSystemClock_FinalReturn;
  char RCC_SelectSystemClock_CallbackBool;
  CMOCK_RCC_SelectSystemClock_CALLBACK RCC_SelectSystemClock_CallbackFunctionPointer;
  int RCC_SelectSystemClock_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE RCC_SelectSystemClock_CallInstance;
  char RCC_EnablePeriphral_IgnoreBool;
  RCC_ErrorStatus_t RCC_EnablePeriphral_FinalReturn;
  char RCC_EnablePeriphral_CallbackBool;
  CMOCK_RCC_EnablePeriphral_CALLBACK RCC_EnablePeriphral_CallbackFunctionPointer;
  int RCC_EnablePeriphral_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE RCC_EnablePeriphral_CallInstance;
  char RCC_DisablePeriphral_IgnoreBool;
  RCC_ErrorStatus_t RCC_DisablePeriphral_FinalReturn;
  char RCC_DisablePeriphral_CallbackBool;
  CMOCK_RCC_DisablePeriphral_CALLBACK RCC_DisablePeriphral_CallbackFunctionPointer;
  int RCC_DisablePeriphral_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE RCC_DisablePeriphral_CallInstance;
  char RCC_SelectAHBPerscaler_IgnoreBool;
  RCC_ErrorStatus_t RCC_SelectAHBPerscaler_FinalReturn;
  char RCC_SelectAHBPerscaler_CallbackBool;
  CMOCK_RCC_SelectAHBPerscaler_CALLBACK RCC_SelectAHBPerscaler_CallbackFunctionPointer;
  int RCC_SelectAHBPerscaler_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE RCC_SelectAHBPerscaler_CallInstance;
  char RCC_SelectAPB1Perscaler_IgnoreBool;
  RCC_ErrorStatus_t RCC_SelectAPB1Perscaler_FinalReturn;
  char RCC_SelectAPB1Perscaler_CallbackBool;
  CMOCK_RCC_SelectAPB1Perscaler_CALLBACK RCC_SelectAPB1Perscaler_CallbackFunctionPointer;
  int RCC_SelectAPB1Perscaler_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE RCC_SelectAPB1Perscaler_CallInstance;
  char RCC_SelectAPB2Perscaler_IgnoreBool;
  RCC_ErrorStatus_t RCC_SelectAPB2Perscaler_FinalReturn;
  char RCC_SelectAPB2Perscaler_CallbackBool;
  CMOCK_RCC_SelectAPB2Perscaler_CALLBACK RCC_SelectAPB2Perscaler_CallbackFunctionPointer;
  int RCC_SelectAPB2Perscaler_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE RCC_SelectAPB2Perscaler_CallInstance;
  char RCC_ConfigurePLL_IgnoreBool;
  RCC_ErrorStatus_t RCC_ConfigurePLL_FinalReturn;
  char RCC_ConfigurePLL_CallbackBool;
  CMOCK_RCC_ConfigurePLL_CALLBACK RCC_ConfigurePLL_CallbackFunctionPointer;
  int RCC_ConfigurePLL_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE RCC_ConfigurePLL_CallInstance;
  char RCC_CheckReadyClk_IgnoreBool;
  RCC_ErrorStatus_t RCC_CheckReadyClk_FinalReturn;
  char RCC_CheckReadyClk_CallbackBool;
  CMOCK_RCC_CheckReadyClk_CALLBACK RCC_CheckReadyClk_CallbackFunctionPointer;
  int RCC_CheckReadyClk_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE RCC_CheckReadyClk_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_RCC_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.RCC_EnableClock_CallInstance;
  if (Mock.RCC_EnableClock_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_RCC_EnableClock);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.RCC_EnableClock_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.RCC_DisableClock_CallInstance;
  if (Mock.RCC_DisableClock_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_RCC_DisableClock);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.RCC_DisableClock_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.RCC_SelectSystemClock_CallInstance;
  if (Mock.RCC_SelectSystemClock_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_RCC_SelectSystemClock);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.RCC_SelectSystemClock_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.RCC_EnablePeriphral_CallInstance;
  if (Mock.RCC_EnablePeriphral_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_RCC_EnablePeriphral);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.RCC_EnablePeriphral_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.RCC_DisablePeriphral_CallInstance;
  if (Mock.RCC_DisablePeriphral_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_RCC_DisablePeriphral);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.RCC_DisablePeriphral_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.RCC_SelectAHBPerscaler_CallInstance;
  if (Mock.RCC_SelectAHBPerscaler_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_RCC_SelectAHBPerscaler);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.RCC_SelectAHBPerscaler_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.RCC_SelectAPB1Perscaler_CallInstance;
  if (Mock.RCC_SelectAPB1Perscaler_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_RCC_SelectAPB1Perscaler);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.RCC_SelectAPB1Perscaler_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.RCC_SelectAPB2Perscaler_CallInstance;
  if (Mock.RCC_SelectAPB2Perscaler_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_RCC_SelectAPB2Perscaler);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.RCC_SelectAPB2Perscaler_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.RCC_ConfigurePLL_CallInstance;
  if (Mock.RCC_ConfigurePLL_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_RCC_ConfigurePLL);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.RCC_ConfigurePLL_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.RCC_CheckReadyClk_CallInstance;
  if (Mock.RCC_CheckReadyClk_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_RCC_CheckReadyClk);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.RCC_CheckReadyClk_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_RCC_Init(void)
{
  mock_RCC_Destroy();
}

void mock_RCC_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

RCC_ErrorStatus_t RCC_EnableClock(u32* ClockRegisterAddress, u32 Clock)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_RCC_EnableClock_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_RCC_EnableClock);
  cmock_call_instance = (CMOCK_RCC_EnableClock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.RCC_EnableClock_CallInstance);
  Mock.RCC_EnableClock_CallInstance = CMock_Guts_MemNext(Mock.RCC_EnableClock_CallInstance);
  if (Mock.RCC_EnableClock_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.RCC_EnableClock_FinalReturn;
    memcpy((void*)(&Mock.RCC_EnableClock_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.RCC_EnableClock_CallbackBool &&
      Mock.RCC_EnableClock_CallbackFunctionPointer != NULL)
  {
    RCC_ErrorStatus_t cmock_cb_ret = Mock.RCC_EnableClock_CallbackFunctionPointer(ClockRegisterAddress, Clock, Mock.RCC_EnableClock_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_RCC_EnableClock,CMockString_ClockRegisterAddress);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ClockRegisterAddress), (void*)(ClockRegisterAddress), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_RCC_EnableClock,CMockString_Clock);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_Clock), (void*)(&Clock), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  if (Mock.RCC_EnableClock_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.RCC_EnableClock_CallbackFunctionPointer(ClockRegisterAddress, Clock, Mock.RCC_EnableClock_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_RCC_EnableClock(CMOCK_RCC_EnableClock_CALL_INSTANCE* cmock_call_instance, u32* ClockRegisterAddress, u32 Clock);
void CMockExpectParameters_RCC_EnableClock(CMOCK_RCC_EnableClock_CALL_INSTANCE* cmock_call_instance, u32* ClockRegisterAddress, u32 Clock)
{
  cmock_call_instance->Expected_ClockRegisterAddress = ClockRegisterAddress;
  memcpy((void*)(&cmock_call_instance->Expected_Clock), (void*)(&Clock),
         sizeof(u32[sizeof(Clock) == sizeof(u32) ? 1 : -1])); /* add u32 to :treat_as_array if this causes an error */
}

void RCC_EnableClock_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_EnableClock_CALL_INSTANCE));
  CMOCK_RCC_EnableClock_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_EnableClock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_EnableClock_CallInstance = CMock_Guts_MemChain(Mock.RCC_EnableClock_CallInstance, cmock_guts_index);
  Mock.RCC_EnableClock_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.RCC_EnableClock_IgnoreBool = (char)1;
}

void RCC_EnableClock_CMockStopIgnore(void)
{
  if(Mock.RCC_EnableClock_IgnoreBool)
    Mock.RCC_EnableClock_CallInstance = CMock_Guts_MemNext(Mock.RCC_EnableClock_CallInstance);
  Mock.RCC_EnableClock_IgnoreBool = (char)0;
}

void RCC_EnableClock_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, u32* ClockRegisterAddress, u32 Clock, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_EnableClock_CALL_INSTANCE));
  CMOCK_RCC_EnableClock_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_EnableClock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_EnableClock_CallInstance = CMock_Guts_MemChain(Mock.RCC_EnableClock_CallInstance, cmock_guts_index);
  Mock.RCC_EnableClock_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_RCC_EnableClock(cmock_call_instance, ClockRegisterAddress, Clock);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_to_return) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
}

void RCC_EnableClock_AddCallback(CMOCK_RCC_EnableClock_CALLBACK Callback)
{
  Mock.RCC_EnableClock_IgnoreBool = (char)0;
  Mock.RCC_EnableClock_CallbackBool = (char)1;
  Mock.RCC_EnableClock_CallbackFunctionPointer = Callback;
}

void RCC_EnableClock_Stub(CMOCK_RCC_EnableClock_CALLBACK Callback)
{
  Mock.RCC_EnableClock_IgnoreBool = (char)0;
  Mock.RCC_EnableClock_CallbackBool = (char)0;
  Mock.RCC_EnableClock_CallbackFunctionPointer = Callback;
}

RCC_ErrorStatus_t RCC_DisableClock(u32* ClockRegisterAddress, u32 Clock)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_RCC_DisableClock_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_RCC_DisableClock);
  cmock_call_instance = (CMOCK_RCC_DisableClock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.RCC_DisableClock_CallInstance);
  Mock.RCC_DisableClock_CallInstance = CMock_Guts_MemNext(Mock.RCC_DisableClock_CallInstance);
  if (Mock.RCC_DisableClock_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.RCC_DisableClock_FinalReturn;
    memcpy((void*)(&Mock.RCC_DisableClock_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.RCC_DisableClock_CallbackBool &&
      Mock.RCC_DisableClock_CallbackFunctionPointer != NULL)
  {
    RCC_ErrorStatus_t cmock_cb_ret = Mock.RCC_DisableClock_CallbackFunctionPointer(ClockRegisterAddress, Clock, Mock.RCC_DisableClock_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_RCC_DisableClock,CMockString_ClockRegisterAddress);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ClockRegisterAddress), (void*)(ClockRegisterAddress), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_RCC_DisableClock,CMockString_Clock);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_Clock), (void*)(&Clock), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  if (Mock.RCC_DisableClock_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.RCC_DisableClock_CallbackFunctionPointer(ClockRegisterAddress, Clock, Mock.RCC_DisableClock_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_RCC_DisableClock(CMOCK_RCC_DisableClock_CALL_INSTANCE* cmock_call_instance, u32* ClockRegisterAddress, u32 Clock);
void CMockExpectParameters_RCC_DisableClock(CMOCK_RCC_DisableClock_CALL_INSTANCE* cmock_call_instance, u32* ClockRegisterAddress, u32 Clock)
{
  cmock_call_instance->Expected_ClockRegisterAddress = ClockRegisterAddress;
  memcpy((void*)(&cmock_call_instance->Expected_Clock), (void*)(&Clock),
         sizeof(u32[sizeof(Clock) == sizeof(u32) ? 1 : -1])); /* add u32 to :treat_as_array if this causes an error */
}

void RCC_DisableClock_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_DisableClock_CALL_INSTANCE));
  CMOCK_RCC_DisableClock_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_DisableClock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_DisableClock_CallInstance = CMock_Guts_MemChain(Mock.RCC_DisableClock_CallInstance, cmock_guts_index);
  Mock.RCC_DisableClock_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.RCC_DisableClock_IgnoreBool = (char)1;
}

void RCC_DisableClock_CMockStopIgnore(void)
{
  if(Mock.RCC_DisableClock_IgnoreBool)
    Mock.RCC_DisableClock_CallInstance = CMock_Guts_MemNext(Mock.RCC_DisableClock_CallInstance);
  Mock.RCC_DisableClock_IgnoreBool = (char)0;
}

void RCC_DisableClock_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, u32* ClockRegisterAddress, u32 Clock, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_DisableClock_CALL_INSTANCE));
  CMOCK_RCC_DisableClock_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_DisableClock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_DisableClock_CallInstance = CMock_Guts_MemChain(Mock.RCC_DisableClock_CallInstance, cmock_guts_index);
  Mock.RCC_DisableClock_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_RCC_DisableClock(cmock_call_instance, ClockRegisterAddress, Clock);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_to_return) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
}

void RCC_DisableClock_AddCallback(CMOCK_RCC_DisableClock_CALLBACK Callback)
{
  Mock.RCC_DisableClock_IgnoreBool = (char)0;
  Mock.RCC_DisableClock_CallbackBool = (char)1;
  Mock.RCC_DisableClock_CallbackFunctionPointer = Callback;
}

void RCC_DisableClock_Stub(CMOCK_RCC_DisableClock_CALLBACK Callback)
{
  Mock.RCC_DisableClock_IgnoreBool = (char)0;
  Mock.RCC_DisableClock_CallbackBool = (char)0;
  Mock.RCC_DisableClock_CallbackFunctionPointer = Callback;
}

RCC_ErrorStatus_t RCC_SelectSystemClock(u32 Sysclk)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_RCC_SelectSystemClock_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_RCC_SelectSystemClock);
  cmock_call_instance = (CMOCK_RCC_SelectSystemClock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.RCC_SelectSystemClock_CallInstance);
  Mock.RCC_SelectSystemClock_CallInstance = CMock_Guts_MemNext(Mock.RCC_SelectSystemClock_CallInstance);
  if (Mock.RCC_SelectSystemClock_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.RCC_SelectSystemClock_FinalReturn;
    memcpy((void*)(&Mock.RCC_SelectSystemClock_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.RCC_SelectSystemClock_CallbackBool &&
      Mock.RCC_SelectSystemClock_CallbackFunctionPointer != NULL)
  {
    RCC_ErrorStatus_t cmock_cb_ret = Mock.RCC_SelectSystemClock_CallbackFunctionPointer(Sysclk, Mock.RCC_SelectSystemClock_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_RCC_SelectSystemClock,CMockString_Sysclk);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_Sysclk), (void*)(&Sysclk), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  if (Mock.RCC_SelectSystemClock_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.RCC_SelectSystemClock_CallbackFunctionPointer(Sysclk, Mock.RCC_SelectSystemClock_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_RCC_SelectSystemClock(CMOCK_RCC_SelectSystemClock_CALL_INSTANCE* cmock_call_instance, u32 Sysclk);
void CMockExpectParameters_RCC_SelectSystemClock(CMOCK_RCC_SelectSystemClock_CALL_INSTANCE* cmock_call_instance, u32 Sysclk)
{
  memcpy((void*)(&cmock_call_instance->Expected_Sysclk), (void*)(&Sysclk),
         sizeof(u32[sizeof(Sysclk) == sizeof(u32) ? 1 : -1])); /* add u32 to :treat_as_array if this causes an error */
}

void RCC_SelectSystemClock_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_SelectSystemClock_CALL_INSTANCE));
  CMOCK_RCC_SelectSystemClock_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_SelectSystemClock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_SelectSystemClock_CallInstance = CMock_Guts_MemChain(Mock.RCC_SelectSystemClock_CallInstance, cmock_guts_index);
  Mock.RCC_SelectSystemClock_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.RCC_SelectSystemClock_IgnoreBool = (char)1;
}

void RCC_SelectSystemClock_CMockStopIgnore(void)
{
  if(Mock.RCC_SelectSystemClock_IgnoreBool)
    Mock.RCC_SelectSystemClock_CallInstance = CMock_Guts_MemNext(Mock.RCC_SelectSystemClock_CallInstance);
  Mock.RCC_SelectSystemClock_IgnoreBool = (char)0;
}

void RCC_SelectSystemClock_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, u32 Sysclk, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_SelectSystemClock_CALL_INSTANCE));
  CMOCK_RCC_SelectSystemClock_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_SelectSystemClock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_SelectSystemClock_CallInstance = CMock_Guts_MemChain(Mock.RCC_SelectSystemClock_CallInstance, cmock_guts_index);
  Mock.RCC_SelectSystemClock_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_RCC_SelectSystemClock(cmock_call_instance, Sysclk);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_to_return) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
}

void RCC_SelectSystemClock_AddCallback(CMOCK_RCC_SelectSystemClock_CALLBACK Callback)
{
  Mock.RCC_SelectSystemClock_IgnoreBool = (char)0;
  Mock.RCC_SelectSystemClock_CallbackBool = (char)1;
  Mock.RCC_SelectSystemClock_CallbackFunctionPointer = Callback;
}

void RCC_SelectSystemClock_Stub(CMOCK_RCC_SelectSystemClock_CALLBACK Callback)
{
  Mock.RCC_SelectSystemClock_IgnoreBool = (char)0;
  Mock.RCC_SelectSystemClock_CallbackBool = (char)0;
  Mock.RCC_SelectSystemClock_CallbackFunctionPointer = Callback;
}

RCC_ErrorStatus_t RCC_EnablePeriphral(u32* PeriphralBus, u32 Periphral)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_RCC_EnablePeriphral_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_RCC_EnablePeriphral);
  cmock_call_instance = (CMOCK_RCC_EnablePeriphral_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.RCC_EnablePeriphral_CallInstance);
  Mock.RCC_EnablePeriphral_CallInstance = CMock_Guts_MemNext(Mock.RCC_EnablePeriphral_CallInstance);
  if (Mock.RCC_EnablePeriphral_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.RCC_EnablePeriphral_FinalReturn;
    memcpy((void*)(&Mock.RCC_EnablePeriphral_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.RCC_EnablePeriphral_CallbackBool &&
      Mock.RCC_EnablePeriphral_CallbackFunctionPointer != NULL)
  {
    RCC_ErrorStatus_t cmock_cb_ret = Mock.RCC_EnablePeriphral_CallbackFunctionPointer(PeriphralBus, Periphral, Mock.RCC_EnablePeriphral_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_RCC_EnablePeriphral,CMockString_PeriphralBus);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_PeriphralBus), (void*)(PeriphralBus), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_RCC_EnablePeriphral,CMockString_Periphral);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_Periphral), (void*)(&Periphral), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  if (Mock.RCC_EnablePeriphral_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.RCC_EnablePeriphral_CallbackFunctionPointer(PeriphralBus, Periphral, Mock.RCC_EnablePeriphral_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_RCC_EnablePeriphral(CMOCK_RCC_EnablePeriphral_CALL_INSTANCE* cmock_call_instance, u32* PeriphralBus, u32 Periphral);
void CMockExpectParameters_RCC_EnablePeriphral(CMOCK_RCC_EnablePeriphral_CALL_INSTANCE* cmock_call_instance, u32* PeriphralBus, u32 Periphral)
{
  cmock_call_instance->Expected_PeriphralBus = PeriphralBus;
  memcpy((void*)(&cmock_call_instance->Expected_Periphral), (void*)(&Periphral),
         sizeof(u32[sizeof(Periphral) == sizeof(u32) ? 1 : -1])); /* add u32 to :treat_as_array if this causes an error */
}

void RCC_EnablePeriphral_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_EnablePeriphral_CALL_INSTANCE));
  CMOCK_RCC_EnablePeriphral_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_EnablePeriphral_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_EnablePeriphral_CallInstance = CMock_Guts_MemChain(Mock.RCC_EnablePeriphral_CallInstance, cmock_guts_index);
  Mock.RCC_EnablePeriphral_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.RCC_EnablePeriphral_IgnoreBool = (char)1;
}

void RCC_EnablePeriphral_CMockStopIgnore(void)
{
  if(Mock.RCC_EnablePeriphral_IgnoreBool)
    Mock.RCC_EnablePeriphral_CallInstance = CMock_Guts_MemNext(Mock.RCC_EnablePeriphral_CallInstance);
  Mock.RCC_EnablePeriphral_IgnoreBool = (char)0;
}

void RCC_EnablePeriphral_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, u32* PeriphralBus, u32 Periphral, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_EnablePeriphral_CALL_INSTANCE));
  CMOCK_RCC_EnablePeriphral_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_EnablePeriphral_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_EnablePeriphral_CallInstance = CMock_Guts_MemChain(Mock.RCC_EnablePeriphral_CallInstance, cmock_guts_index);
  Mock.RCC_EnablePeriphral_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_RCC_EnablePeriphral(cmock_call_instance, PeriphralBus, Periphral);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_to_return) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
}

void RCC_EnablePeriphral_AddCallback(CMOCK_RCC_EnablePeriphral_CALLBACK Callback)
{
  Mock.RCC_EnablePeriphral_IgnoreBool = (char)0;
  Mock.RCC_EnablePeriphral_CallbackBool = (char)1;
  Mock.RCC_EnablePeriphral_CallbackFunctionPointer = Callback;
}

void RCC_EnablePeriphral_Stub(CMOCK_RCC_EnablePeriphral_CALLBACK Callback)
{
  Mock.RCC_EnablePeriphral_IgnoreBool = (char)0;
  Mock.RCC_EnablePeriphral_CallbackBool = (char)0;
  Mock.RCC_EnablePeriphral_CallbackFunctionPointer = Callback;
}

RCC_ErrorStatus_t RCC_DisablePeriphral(u32* PeriphralBus, u32 Periphral)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_RCC_DisablePeriphral_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_RCC_DisablePeriphral);
  cmock_call_instance = (CMOCK_RCC_DisablePeriphral_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.RCC_DisablePeriphral_CallInstance);
  Mock.RCC_DisablePeriphral_CallInstance = CMock_Guts_MemNext(Mock.RCC_DisablePeriphral_CallInstance);
  if (Mock.RCC_DisablePeriphral_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.RCC_DisablePeriphral_FinalReturn;
    memcpy((void*)(&Mock.RCC_DisablePeriphral_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.RCC_DisablePeriphral_CallbackBool &&
      Mock.RCC_DisablePeriphral_CallbackFunctionPointer != NULL)
  {
    RCC_ErrorStatus_t cmock_cb_ret = Mock.RCC_DisablePeriphral_CallbackFunctionPointer(PeriphralBus, Periphral, Mock.RCC_DisablePeriphral_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_RCC_DisablePeriphral,CMockString_PeriphralBus);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_PeriphralBus), (void*)(PeriphralBus), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_RCC_DisablePeriphral,CMockString_Periphral);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_Periphral), (void*)(&Periphral), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  if (Mock.RCC_DisablePeriphral_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.RCC_DisablePeriphral_CallbackFunctionPointer(PeriphralBus, Periphral, Mock.RCC_DisablePeriphral_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_RCC_DisablePeriphral(CMOCK_RCC_DisablePeriphral_CALL_INSTANCE* cmock_call_instance, u32* PeriphralBus, u32 Periphral);
void CMockExpectParameters_RCC_DisablePeriphral(CMOCK_RCC_DisablePeriphral_CALL_INSTANCE* cmock_call_instance, u32* PeriphralBus, u32 Periphral)
{
  cmock_call_instance->Expected_PeriphralBus = PeriphralBus;
  memcpy((void*)(&cmock_call_instance->Expected_Periphral), (void*)(&Periphral),
         sizeof(u32[sizeof(Periphral) == sizeof(u32) ? 1 : -1])); /* add u32 to :treat_as_array if this causes an error */
}

void RCC_DisablePeriphral_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_DisablePeriphral_CALL_INSTANCE));
  CMOCK_RCC_DisablePeriphral_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_DisablePeriphral_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_DisablePeriphral_CallInstance = CMock_Guts_MemChain(Mock.RCC_DisablePeriphral_CallInstance, cmock_guts_index);
  Mock.RCC_DisablePeriphral_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.RCC_DisablePeriphral_IgnoreBool = (char)1;
}

void RCC_DisablePeriphral_CMockStopIgnore(void)
{
  if(Mock.RCC_DisablePeriphral_IgnoreBool)
    Mock.RCC_DisablePeriphral_CallInstance = CMock_Guts_MemNext(Mock.RCC_DisablePeriphral_CallInstance);
  Mock.RCC_DisablePeriphral_IgnoreBool = (char)0;
}

void RCC_DisablePeriphral_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, u32* PeriphralBus, u32 Periphral, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_DisablePeriphral_CALL_INSTANCE));
  CMOCK_RCC_DisablePeriphral_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_DisablePeriphral_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_DisablePeriphral_CallInstance = CMock_Guts_MemChain(Mock.RCC_DisablePeriphral_CallInstance, cmock_guts_index);
  Mock.RCC_DisablePeriphral_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_RCC_DisablePeriphral(cmock_call_instance, PeriphralBus, Periphral);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_to_return) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
}

void RCC_DisablePeriphral_AddCallback(CMOCK_RCC_DisablePeriphral_CALLBACK Callback)
{
  Mock.RCC_DisablePeriphral_IgnoreBool = (char)0;
  Mock.RCC_DisablePeriphral_CallbackBool = (char)1;
  Mock.RCC_DisablePeriphral_CallbackFunctionPointer = Callback;
}

void RCC_DisablePeriphral_Stub(CMOCK_RCC_DisablePeriphral_CALLBACK Callback)
{
  Mock.RCC_DisablePeriphral_IgnoreBool = (char)0;
  Mock.RCC_DisablePeriphral_CallbackBool = (char)0;
  Mock.RCC_DisablePeriphral_CallbackFunctionPointer = Callback;
}

RCC_ErrorStatus_t RCC_SelectAHBPerscaler(u32 AHBPrescaler)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_RCC_SelectAHBPerscaler_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_RCC_SelectAHBPerscaler);
  cmock_call_instance = (CMOCK_RCC_SelectAHBPerscaler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.RCC_SelectAHBPerscaler_CallInstance);
  Mock.RCC_SelectAHBPerscaler_CallInstance = CMock_Guts_MemNext(Mock.RCC_SelectAHBPerscaler_CallInstance);
  if (Mock.RCC_SelectAHBPerscaler_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.RCC_SelectAHBPerscaler_FinalReturn;
    memcpy((void*)(&Mock.RCC_SelectAHBPerscaler_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.RCC_SelectAHBPerscaler_CallbackBool &&
      Mock.RCC_SelectAHBPerscaler_CallbackFunctionPointer != NULL)
  {
    RCC_ErrorStatus_t cmock_cb_ret = Mock.RCC_SelectAHBPerscaler_CallbackFunctionPointer(AHBPrescaler, Mock.RCC_SelectAHBPerscaler_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_RCC_SelectAHBPerscaler,CMockString_AHBPrescaler);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_AHBPrescaler), (void*)(&AHBPrescaler), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  if (Mock.RCC_SelectAHBPerscaler_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.RCC_SelectAHBPerscaler_CallbackFunctionPointer(AHBPrescaler, Mock.RCC_SelectAHBPerscaler_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_RCC_SelectAHBPerscaler(CMOCK_RCC_SelectAHBPerscaler_CALL_INSTANCE* cmock_call_instance, u32 AHBPrescaler);
void CMockExpectParameters_RCC_SelectAHBPerscaler(CMOCK_RCC_SelectAHBPerscaler_CALL_INSTANCE* cmock_call_instance, u32 AHBPrescaler)
{
  memcpy((void*)(&cmock_call_instance->Expected_AHBPrescaler), (void*)(&AHBPrescaler),
         sizeof(u32[sizeof(AHBPrescaler) == sizeof(u32) ? 1 : -1])); /* add u32 to :treat_as_array if this causes an error */
}

void RCC_SelectAHBPerscaler_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_SelectAHBPerscaler_CALL_INSTANCE));
  CMOCK_RCC_SelectAHBPerscaler_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_SelectAHBPerscaler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_SelectAHBPerscaler_CallInstance = CMock_Guts_MemChain(Mock.RCC_SelectAHBPerscaler_CallInstance, cmock_guts_index);
  Mock.RCC_SelectAHBPerscaler_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.RCC_SelectAHBPerscaler_IgnoreBool = (char)1;
}

void RCC_SelectAHBPerscaler_CMockStopIgnore(void)
{
  if(Mock.RCC_SelectAHBPerscaler_IgnoreBool)
    Mock.RCC_SelectAHBPerscaler_CallInstance = CMock_Guts_MemNext(Mock.RCC_SelectAHBPerscaler_CallInstance);
  Mock.RCC_SelectAHBPerscaler_IgnoreBool = (char)0;
}

void RCC_SelectAHBPerscaler_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, u32 AHBPrescaler, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_SelectAHBPerscaler_CALL_INSTANCE));
  CMOCK_RCC_SelectAHBPerscaler_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_SelectAHBPerscaler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_SelectAHBPerscaler_CallInstance = CMock_Guts_MemChain(Mock.RCC_SelectAHBPerscaler_CallInstance, cmock_guts_index);
  Mock.RCC_SelectAHBPerscaler_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_RCC_SelectAHBPerscaler(cmock_call_instance, AHBPrescaler);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_to_return) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
}

void RCC_SelectAHBPerscaler_AddCallback(CMOCK_RCC_SelectAHBPerscaler_CALLBACK Callback)
{
  Mock.RCC_SelectAHBPerscaler_IgnoreBool = (char)0;
  Mock.RCC_SelectAHBPerscaler_CallbackBool = (char)1;
  Mock.RCC_SelectAHBPerscaler_CallbackFunctionPointer = Callback;
}

void RCC_SelectAHBPerscaler_Stub(CMOCK_RCC_SelectAHBPerscaler_CALLBACK Callback)
{
  Mock.RCC_SelectAHBPerscaler_IgnoreBool = (char)0;
  Mock.RCC_SelectAHBPerscaler_CallbackBool = (char)0;
  Mock.RCC_SelectAHBPerscaler_CallbackFunctionPointer = Callback;
}

RCC_ErrorStatus_t RCC_SelectAPB1Perscaler(u32 APB1Prescaler)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_RCC_SelectAPB1Perscaler_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_RCC_SelectAPB1Perscaler);
  cmock_call_instance = (CMOCK_RCC_SelectAPB1Perscaler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.RCC_SelectAPB1Perscaler_CallInstance);
  Mock.RCC_SelectAPB1Perscaler_CallInstance = CMock_Guts_MemNext(Mock.RCC_SelectAPB1Perscaler_CallInstance);
  if (Mock.RCC_SelectAPB1Perscaler_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.RCC_SelectAPB1Perscaler_FinalReturn;
    memcpy((void*)(&Mock.RCC_SelectAPB1Perscaler_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.RCC_SelectAPB1Perscaler_CallbackBool &&
      Mock.RCC_SelectAPB1Perscaler_CallbackFunctionPointer != NULL)
  {
    RCC_ErrorStatus_t cmock_cb_ret = Mock.RCC_SelectAPB1Perscaler_CallbackFunctionPointer(APB1Prescaler, Mock.RCC_SelectAPB1Perscaler_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_RCC_SelectAPB1Perscaler,CMockString_APB1Prescaler);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_APB1Prescaler), (void*)(&APB1Prescaler), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  if (Mock.RCC_SelectAPB1Perscaler_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.RCC_SelectAPB1Perscaler_CallbackFunctionPointer(APB1Prescaler, Mock.RCC_SelectAPB1Perscaler_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_RCC_SelectAPB1Perscaler(CMOCK_RCC_SelectAPB1Perscaler_CALL_INSTANCE* cmock_call_instance, u32 APB1Prescaler);
void CMockExpectParameters_RCC_SelectAPB1Perscaler(CMOCK_RCC_SelectAPB1Perscaler_CALL_INSTANCE* cmock_call_instance, u32 APB1Prescaler)
{
  memcpy((void*)(&cmock_call_instance->Expected_APB1Prescaler), (void*)(&APB1Prescaler),
         sizeof(u32[sizeof(APB1Prescaler) == sizeof(u32) ? 1 : -1])); /* add u32 to :treat_as_array if this causes an error */
}

void RCC_SelectAPB1Perscaler_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_SelectAPB1Perscaler_CALL_INSTANCE));
  CMOCK_RCC_SelectAPB1Perscaler_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_SelectAPB1Perscaler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_SelectAPB1Perscaler_CallInstance = CMock_Guts_MemChain(Mock.RCC_SelectAPB1Perscaler_CallInstance, cmock_guts_index);
  Mock.RCC_SelectAPB1Perscaler_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.RCC_SelectAPB1Perscaler_IgnoreBool = (char)1;
}

void RCC_SelectAPB1Perscaler_CMockStopIgnore(void)
{
  if(Mock.RCC_SelectAPB1Perscaler_IgnoreBool)
    Mock.RCC_SelectAPB1Perscaler_CallInstance = CMock_Guts_MemNext(Mock.RCC_SelectAPB1Perscaler_CallInstance);
  Mock.RCC_SelectAPB1Perscaler_IgnoreBool = (char)0;
}

void RCC_SelectAPB1Perscaler_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, u32 APB1Prescaler, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_SelectAPB1Perscaler_CALL_INSTANCE));
  CMOCK_RCC_SelectAPB1Perscaler_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_SelectAPB1Perscaler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_SelectAPB1Perscaler_CallInstance = CMock_Guts_MemChain(Mock.RCC_SelectAPB1Perscaler_CallInstance, cmock_guts_index);
  Mock.RCC_SelectAPB1Perscaler_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_RCC_SelectAPB1Perscaler(cmock_call_instance, APB1Prescaler);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_to_return) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
}

void RCC_SelectAPB1Perscaler_AddCallback(CMOCK_RCC_SelectAPB1Perscaler_CALLBACK Callback)
{
  Mock.RCC_SelectAPB1Perscaler_IgnoreBool = (char)0;
  Mock.RCC_SelectAPB1Perscaler_CallbackBool = (char)1;
  Mock.RCC_SelectAPB1Perscaler_CallbackFunctionPointer = Callback;
}

void RCC_SelectAPB1Perscaler_Stub(CMOCK_RCC_SelectAPB1Perscaler_CALLBACK Callback)
{
  Mock.RCC_SelectAPB1Perscaler_IgnoreBool = (char)0;
  Mock.RCC_SelectAPB1Perscaler_CallbackBool = (char)0;
  Mock.RCC_SelectAPB1Perscaler_CallbackFunctionPointer = Callback;
}

RCC_ErrorStatus_t RCC_SelectAPB2Perscaler(u32 APB2Prescaler)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_RCC_SelectAPB2Perscaler_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_RCC_SelectAPB2Perscaler);
  cmock_call_instance = (CMOCK_RCC_SelectAPB2Perscaler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.RCC_SelectAPB2Perscaler_CallInstance);
  Mock.RCC_SelectAPB2Perscaler_CallInstance = CMock_Guts_MemNext(Mock.RCC_SelectAPB2Perscaler_CallInstance);
  if (Mock.RCC_SelectAPB2Perscaler_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.RCC_SelectAPB2Perscaler_FinalReturn;
    memcpy((void*)(&Mock.RCC_SelectAPB2Perscaler_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.RCC_SelectAPB2Perscaler_CallbackBool &&
      Mock.RCC_SelectAPB2Perscaler_CallbackFunctionPointer != NULL)
  {
    RCC_ErrorStatus_t cmock_cb_ret = Mock.RCC_SelectAPB2Perscaler_CallbackFunctionPointer(APB2Prescaler, Mock.RCC_SelectAPB2Perscaler_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_RCC_SelectAPB2Perscaler,CMockString_APB2Prescaler);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_APB2Prescaler), (void*)(&APB2Prescaler), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  if (Mock.RCC_SelectAPB2Perscaler_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.RCC_SelectAPB2Perscaler_CallbackFunctionPointer(APB2Prescaler, Mock.RCC_SelectAPB2Perscaler_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_RCC_SelectAPB2Perscaler(CMOCK_RCC_SelectAPB2Perscaler_CALL_INSTANCE* cmock_call_instance, u32 APB2Prescaler);
void CMockExpectParameters_RCC_SelectAPB2Perscaler(CMOCK_RCC_SelectAPB2Perscaler_CALL_INSTANCE* cmock_call_instance, u32 APB2Prescaler)
{
  memcpy((void*)(&cmock_call_instance->Expected_APB2Prescaler), (void*)(&APB2Prescaler),
         sizeof(u32[sizeof(APB2Prescaler) == sizeof(u32) ? 1 : -1])); /* add u32 to :treat_as_array if this causes an error */
}

void RCC_SelectAPB2Perscaler_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_SelectAPB2Perscaler_CALL_INSTANCE));
  CMOCK_RCC_SelectAPB2Perscaler_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_SelectAPB2Perscaler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_SelectAPB2Perscaler_CallInstance = CMock_Guts_MemChain(Mock.RCC_SelectAPB2Perscaler_CallInstance, cmock_guts_index);
  Mock.RCC_SelectAPB2Perscaler_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.RCC_SelectAPB2Perscaler_IgnoreBool = (char)1;
}

void RCC_SelectAPB2Perscaler_CMockStopIgnore(void)
{
  if(Mock.RCC_SelectAPB2Perscaler_IgnoreBool)
    Mock.RCC_SelectAPB2Perscaler_CallInstance = CMock_Guts_MemNext(Mock.RCC_SelectAPB2Perscaler_CallInstance);
  Mock.RCC_SelectAPB2Perscaler_IgnoreBool = (char)0;
}

void RCC_SelectAPB2Perscaler_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, u32 APB2Prescaler, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_SelectAPB2Perscaler_CALL_INSTANCE));
  CMOCK_RCC_SelectAPB2Perscaler_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_SelectAPB2Perscaler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_SelectAPB2Perscaler_CallInstance = CMock_Guts_MemChain(Mock.RCC_SelectAPB2Perscaler_CallInstance, cmock_guts_index);
  Mock.RCC_SelectAPB2Perscaler_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_RCC_SelectAPB2Perscaler(cmock_call_instance, APB2Prescaler);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_to_return) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
}

void RCC_SelectAPB2Perscaler_AddCallback(CMOCK_RCC_SelectAPB2Perscaler_CALLBACK Callback)
{
  Mock.RCC_SelectAPB2Perscaler_IgnoreBool = (char)0;
  Mock.RCC_SelectAPB2Perscaler_CallbackBool = (char)1;
  Mock.RCC_SelectAPB2Perscaler_CallbackFunctionPointer = Callback;
}

void RCC_SelectAPB2Perscaler_Stub(CMOCK_RCC_SelectAPB2Perscaler_CALLBACK Callback)
{
  Mock.RCC_SelectAPB2Perscaler_IgnoreBool = (char)0;
  Mock.RCC_SelectAPB2Perscaler_CallbackBool = (char)0;
  Mock.RCC_SelectAPB2Perscaler_CallbackFunctionPointer = Callback;
}

RCC_ErrorStatus_t RCC_ConfigurePLL(PLLCfgOptions_t* PLLCfg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_RCC_ConfigurePLL_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_RCC_ConfigurePLL);
  cmock_call_instance = (CMOCK_RCC_ConfigurePLL_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.RCC_ConfigurePLL_CallInstance);
  Mock.RCC_ConfigurePLL_CallInstance = CMock_Guts_MemNext(Mock.RCC_ConfigurePLL_CallInstance);
  if (Mock.RCC_ConfigurePLL_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.RCC_ConfigurePLL_FinalReturn;
    memcpy((void*)(&Mock.RCC_ConfigurePLL_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.RCC_ConfigurePLL_CallbackBool &&
      Mock.RCC_ConfigurePLL_CallbackFunctionPointer != NULL)
  {
    RCC_ErrorStatus_t cmock_cb_ret = Mock.RCC_ConfigurePLL_CallbackFunctionPointer(PLLCfg, Mock.RCC_ConfigurePLL_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_RCC_ConfigurePLL,CMockString_PLLCfg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_PLLCfg), (void*)(PLLCfg), sizeof(PLLCfgOptions_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.RCC_ConfigurePLL_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.RCC_ConfigurePLL_CallbackFunctionPointer(PLLCfg, Mock.RCC_ConfigurePLL_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_RCC_ConfigurePLL(CMOCK_RCC_ConfigurePLL_CALL_INSTANCE* cmock_call_instance, PLLCfgOptions_t* PLLCfg);
void CMockExpectParameters_RCC_ConfigurePLL(CMOCK_RCC_ConfigurePLL_CALL_INSTANCE* cmock_call_instance, PLLCfgOptions_t* PLLCfg)
{
  cmock_call_instance->Expected_PLLCfg = PLLCfg;
}

void RCC_ConfigurePLL_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_ConfigurePLL_CALL_INSTANCE));
  CMOCK_RCC_ConfigurePLL_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_ConfigurePLL_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_ConfigurePLL_CallInstance = CMock_Guts_MemChain(Mock.RCC_ConfigurePLL_CallInstance, cmock_guts_index);
  Mock.RCC_ConfigurePLL_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.RCC_ConfigurePLL_IgnoreBool = (char)1;
}

void RCC_ConfigurePLL_CMockStopIgnore(void)
{
  if(Mock.RCC_ConfigurePLL_IgnoreBool)
    Mock.RCC_ConfigurePLL_CallInstance = CMock_Guts_MemNext(Mock.RCC_ConfigurePLL_CallInstance);
  Mock.RCC_ConfigurePLL_IgnoreBool = (char)0;
}

void RCC_ConfigurePLL_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, PLLCfgOptions_t* PLLCfg, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_ConfigurePLL_CALL_INSTANCE));
  CMOCK_RCC_ConfigurePLL_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_ConfigurePLL_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_ConfigurePLL_CallInstance = CMock_Guts_MemChain(Mock.RCC_ConfigurePLL_CallInstance, cmock_guts_index);
  Mock.RCC_ConfigurePLL_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_RCC_ConfigurePLL(cmock_call_instance, PLLCfg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_to_return) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
}

void RCC_ConfigurePLL_AddCallback(CMOCK_RCC_ConfigurePLL_CALLBACK Callback)
{
  Mock.RCC_ConfigurePLL_IgnoreBool = (char)0;
  Mock.RCC_ConfigurePLL_CallbackBool = (char)1;
  Mock.RCC_ConfigurePLL_CallbackFunctionPointer = Callback;
}

void RCC_ConfigurePLL_Stub(CMOCK_RCC_ConfigurePLL_CALLBACK Callback)
{
  Mock.RCC_ConfigurePLL_IgnoreBool = (char)0;
  Mock.RCC_ConfigurePLL_CallbackBool = (char)0;
  Mock.RCC_ConfigurePLL_CallbackFunctionPointer = Callback;
}

RCC_ErrorStatus_t RCC_CheckReadyClk(u32* ClockRegisterAddress, u32 ReadyMask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_RCC_CheckReadyClk_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_RCC_CheckReadyClk);
  cmock_call_instance = (CMOCK_RCC_CheckReadyClk_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.RCC_CheckReadyClk_CallInstance);
  Mock.RCC_CheckReadyClk_CallInstance = CMock_Guts_MemNext(Mock.RCC_CheckReadyClk_CallInstance);
  if (Mock.RCC_CheckReadyClk_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.RCC_CheckReadyClk_FinalReturn;
    memcpy((void*)(&Mock.RCC_CheckReadyClk_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.RCC_CheckReadyClk_CallbackBool &&
      Mock.RCC_CheckReadyClk_CallbackFunctionPointer != NULL)
  {
    RCC_ErrorStatus_t cmock_cb_ret = Mock.RCC_CheckReadyClk_CallbackFunctionPointer(ClockRegisterAddress, ReadyMask, Mock.RCC_CheckReadyClk_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_RCC_CheckReadyClk,CMockString_ClockRegisterAddress);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ClockRegisterAddress), (void*)(ClockRegisterAddress), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_RCC_CheckReadyClk,CMockString_ReadyMask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ReadyMask), (void*)(&ReadyMask), sizeof(u32), cmock_line, CMockStringMismatch);
  }
  if (Mock.RCC_CheckReadyClk_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.RCC_CheckReadyClk_CallbackFunctionPointer(ClockRegisterAddress, ReadyMask, Mock.RCC_CheckReadyClk_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_RCC_CheckReadyClk(CMOCK_RCC_CheckReadyClk_CALL_INSTANCE* cmock_call_instance, u32* ClockRegisterAddress, u32 ReadyMask);
void CMockExpectParameters_RCC_CheckReadyClk(CMOCK_RCC_CheckReadyClk_CALL_INSTANCE* cmock_call_instance, u32* ClockRegisterAddress, u32 ReadyMask)
{
  cmock_call_instance->Expected_ClockRegisterAddress = ClockRegisterAddress;
  memcpy((void*)(&cmock_call_instance->Expected_ReadyMask), (void*)(&ReadyMask),
         sizeof(u32[sizeof(ReadyMask) == sizeof(u32) ? 1 : -1])); /* add u32 to :treat_as_array if this causes an error */
}

void RCC_CheckReadyClk_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_CheckReadyClk_CALL_INSTANCE));
  CMOCK_RCC_CheckReadyClk_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_CheckReadyClk_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_CheckReadyClk_CallInstance = CMock_Guts_MemChain(Mock.RCC_CheckReadyClk_CallInstance, cmock_guts_index);
  Mock.RCC_CheckReadyClk_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.RCC_CheckReadyClk_IgnoreBool = (char)1;
}

void RCC_CheckReadyClk_CMockStopIgnore(void)
{
  if(Mock.RCC_CheckReadyClk_IgnoreBool)
    Mock.RCC_CheckReadyClk_CallInstance = CMock_Guts_MemNext(Mock.RCC_CheckReadyClk_CallInstance);
  Mock.RCC_CheckReadyClk_IgnoreBool = (char)0;
}

void RCC_CheckReadyClk_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, u32* ClockRegisterAddress, u32 ReadyMask, RCC_ErrorStatus_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_RCC_CheckReadyClk_CALL_INSTANCE));
  CMOCK_RCC_CheckReadyClk_CALL_INSTANCE* cmock_call_instance = (CMOCK_RCC_CheckReadyClk_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.RCC_CheckReadyClk_CallInstance = CMock_Guts_MemChain(Mock.RCC_CheckReadyClk_CallInstance, cmock_guts_index);
  Mock.RCC_CheckReadyClk_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_RCC_CheckReadyClk(cmock_call_instance, ClockRegisterAddress, ReadyMask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(RCC_ErrorStatus_t[sizeof(cmock_to_return) == sizeof(RCC_ErrorStatus_t) ? 1 : -1])); /* add RCC_ErrorStatus_t to :treat_as_array if this causes an error */
}

void RCC_CheckReadyClk_AddCallback(CMOCK_RCC_CheckReadyClk_CALLBACK Callback)
{
  Mock.RCC_CheckReadyClk_IgnoreBool = (char)0;
  Mock.RCC_CheckReadyClk_CallbackBool = (char)1;
  Mock.RCC_CheckReadyClk_CallbackFunctionPointer = Callback;
}

void RCC_CheckReadyClk_Stub(CMOCK_RCC_CheckReadyClk_CALLBACK Callback)
{
  Mock.RCC_CheckReadyClk_IgnoreBool = (char)0;
  Mock.RCC_CheckReadyClk_CallbackBool = (char)0;
  Mock.RCC_CheckReadyClk_CallbackFunctionPointer = Callback;
}

